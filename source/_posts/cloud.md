1、优化
1. 索引优化
- 创建索引：在经常查询的字段上创建索引，尤其是主键、外键、和经常作为查询条件的字段。
- 复合索引：对于多列经常一起查询的情况，使用复合索引可以提升性能。
- 覆盖索引：查询只用到索引中的字段，可以避免回表，提高查询速度。
2. 查询优化
- 避免SELECT *：只查询需要的字段，减少数据传输量。
- 使用EXISTS代替IN：对于子查询，使用EXISTS可以在很多情况下比IN更高效。
- 避免子查询：尽量使用JOIN代替子查询，子查询在某些情况下性能较差。
- 合理使用LIMIT：对大数据量的查询使用LIMIT分页，避免一次性加载大量数据。
3. 表结构优化
- 范式化设计：根据实际情况对数据库进行范式化设计，减少数据冗余和更新异常。
- 分区表：对于大表进行分区，可以提高查询和管理的性能。
- 垂直分割：将表中列数很多但使用频率不一致的字段拆分成多张表。
- 水平分割：将大表按行拆分成多个表，分散数据存储压力。
4. 缓存优化
- 查询缓存：启用MySQL的查询缓存（需要注意的是，某些版本和场景下可能会被弃用）。
- 应用层缓存：在应用层使用缓存，如Redis，减少对数据库的直接访问频率。
5. 事务优化
- 合理使用事务：控制事务的大小，尽量减少长时间占用资源的事务操作。
- 锁的优化：减少锁的范围和时间，尽量使用行锁代替表锁，避免死锁。
6. SQL优化工具
- EXPLAIN：使用EXPLAIN关键字来分析SQL执行计划，找出查询中的瓶颈。
- 慢查询日志：开启慢查询日志，分析慢查询，针对性优化。
7. 配置优化
- 调整缓冲池大小：如innodb_buffer_pool_size等配置，根据服务器内存情况调整，提升InnoDB的性能。
- 连接池配置：合理配置数据库连接池，提高并发处理能力。
  2、底层B+不是b树，为什么
  b树：每个节点可以存多个元素，有多个节点，每个节点也会排序。
  b+树： b树的plus版，每个子节点之间也有指针，范围查询非常高效，可以在叶子节点中遍历内部节点只存                                                   储索引键，不存储数据记录，
  由于 B+ 树的叶子节点形成有序链表，当需要顺序访问数据时，可以减少随机 IO，提高磁盘读取效率。

3、乐观锁、悲观锁
乐观锁：        适用于读多写少、冲突概率低的应用，如前端应用和缓存系统。
在一个电商系统中，多个用户同时对某个商品进行下单操作，此时可以采用乐观锁机制。
在用户下单时，先读取该商品的库存数量和版本号，并将库存减去用户购买的数量，版本号加1。如果更新时发现版本号已经被其他事务修改，则说明库存已经被其他用户购买，需要进行回滚或重试操作。
在更新数据时，先检查版本是否一致，若一致则更新成功，否则说明有其他事务修改过数据，需要重新读取数据进行更新。
悲观锁：        适用于写多读少、冲突概率高的应用，如银行交易系统和库存管理系统。
在一个银行系统中，多个用户同时对某个账户进行转账操作，此时可以采用悲观锁机制。
在用户进行转账时，先锁定账户，避免其他用户同时对其进行操作。在转账完成后，释放锁定，让其他用户可以对该账户进行操作。


4、 索引失效
1、 like查询以%开头，  like %a 会失效 但是 like a% 不会。a%可以筛选出索引相关的值，并且mysql会自动排序。
2、 类型转化（索引字段和条件或者关联字段类型不一致），列计算（±*/）。
3、 全表扫描。
4、条件中有or且or连接字段中的列没有索引，那么即使其中有条件带索引也不会使用索引。当检索条件中有or但是所有条件都有索引时索引不会失效。
5、复合索引不满足最左原则。
6，使用 != , is null , is not null时，使用order by ，使用函数时，索引会失效。

5、分库分表：ShardingSphere

    1.    配置 ShardingSphere：在现有系统中配置 ShardingSphere，设置分库分表规则。
    2.    双写机制：在应用程序中实现数据同时写入旧数据库和 ShardingSphere 代理层。
    3.    数据迁移：使用 ShardingSphere 提供的数据迁移工具将现有数据迁移到新的分库分表结构。
    4.    逐步切换：在 ShardingSphere 中配置负载均衡，将部分流量切换到新的数据库结构中。
    5.    监控和优化：在切换后监控系统性能，进行必要的优化。

2、全局唯一id
雪花算法、UUID、KeyGenerator接口、自增（分布式不可以）
sharding:
keyGenerator:
type: SNOWFLAKE
column: order_id
maxWidth: 10
6、Mysql和PgSql区别
隔离级别：    Mysql默认可重复读，   防止幻读
PgSQL默认读已提交，可以防止脏读
自动提交：
MySql，默认开启的，可以 SET autocommit = 0 来关闭自动提交模式。
PostgreSQL:    自动提交默认也是开启的，但更常使用显式事务块 (BEGIN; ... COMMIT;) 来处理事务。
锁机制：
MySQL:         InnoDB 使用行级锁和表级锁，主要依赖于行级锁来实现高并发
PostgreSQL:    使用行级锁，几乎不使用表级锁，这使得其在高并发场景下具有更好的性能。

7、选择 PostgreSQL 而不是 MySQL的原因？

PostgreSQL 在数据完整性和一致性方面表现出色。它从设计上全面支持 ACID 特性，所有操作都是事务安全的，这对于需要高数据一致性的应用场景尤为重要。
PostgreSQL 对 SQL 标准的兼容性更高，支持更多的 SQL 特性和高级功能，例如窗口函数、通用表表达式 (CTE) 和复杂子查询等。这使得在处理复杂查询时，PostgreSQL 更加高效和灵活。
PostgreSQL 的扩展性和定制化能力很强。它允许用户创建自定义数据类型、操作符和存储过程，并且拥有丰富的扩展插件，如 PostGIS (地理空间数据支持) 和 pg_stat_statements (查询统计) 等。


8、mysql存储过程
一段预编译的SQL代码，存储在数据库中，可以通过call调用执行。

**DELIMITER** \$\$开始，

**CREATE PROCEDURE**  my\_proc(IN param1 INT, OUT param2 INT)&#x20;
-- 声明两个变量及其类型
DECLARE var1 INT DEFAULT 0;
DECLARE var2 VARCHAR(50);

            -- 判断参数是否为空
                IF param1 IS NULL THEN
    select ***
    update ***

**END**

**DELIMITER 结束**
9、一条sql发送给mysql后，内部是如何执行的？
1、语法分析：MySQL 首先会检查 SQL 语句是否符合语法规则，如果存在语法错误，则会返回错误信息。2、权限验证：MySQL 会验证用户是否具有执行该语句的权限，如果没有权限，则会返回错误信息。3、查询优化：MySQL 会对查询语句进行优化，选择最优的执行计划。MySQL 使用查询执行计划来确定如何执行 SQL 查询， 并在执行过程中利用缓存等机制来提高执行效率。4、数据读取：MySQL 执行查询语句，并从数据库中读取数据。5、数据操作：如果是更新、插入或删除数据，MySQL 会对数据进行操作，并更新数据库中的数据。6、数据返回：MySQL 将查询结果返回给用户。
10、主从延迟问题
将查询请求进行分类：
一类是对数据实时性要求不高的请求，这种请求直接去读从库；
另一类则是对实时性要求比较高的请求，这种就强制读主库。
11、存储引擎
show engines常用：InnoDB、MyISAM、MEMORY
InnoDB  :    它支持事务、支持外键、支持崩溃修复和自增列。读写效率较差、占用的数据空间较大
MyISAM：  读取效率较高，占用数据空间较少，但不支持事务、行级锁、外键等特性。
MEMORY：读取效率较高，MySQL 服务重启之后数据会丢失。不支持事物、外键
12、索引底层是如何实现的
B+树，
非叶子节点存储的是索引字段的值，叶子节点存储了所有的数据行信息


查询效率：查询底层节点的磁盘 I/O 次数会更少。
删除效率：直接从子节点删除，树形结构变化很小。
范围查询：所有叶子节点间还有一个链表进行连接，很快。

13、行锁、表锁、间隙锁

行锁是在数据行级别上实现的锁，它可以防止多个事务同时修改同一行数据。下面是一个示例：
-- 会话 1
BEGIN;
SELECT * FROM orders WHERE id = 1 FOR UPDATE;
-- 对 id=1 的数据行进行修改
UPDATE orders SET amount = amount + 100 WHERE id = 1;
COMMIT;

-- 会话 2
BEGIN;
-- 因为会话 1 对 id=1 的数据行进行了行锁，所以会话 2 不能同时对该行进行修改，
-- 如果执行下面的语句会一直等待会话 1 的事务提交或回滚
UPDATE orders SET amount = amount - 50 WHERE id = 1;

表锁是在表级别上实现的锁，它可以防止多个事务同时修改整个表。下面是一个示例：
-- 会话 1
BEGIN;
LOCK TABLES orders WRITE;
-- 对整个表进行修改
UPDATE orders SET amount = amount + 100;
COMMIT;
UNLOCK TABLES;

-- 会话 2
BEGIN;
-- 因为会话 1 对 orders 表进行了表锁，所以会话 2 不能同时对该表进行修改，
-- 如果执行下面的语句会一直等待会话 1 的事务提交或回滚
UPDATE orders SET amount = amount - 50;

间隙锁是在索引上实现的锁，它可以防止其他事务插入数据到锁定的范围内。下面是一个示例：
-- 会话 1
BEGIN;
-- 对 id 大于 1 小于 10 的范围进行间隙锁定，排他锁
SELECT * FROM orders WHERE id > 1 AND id < 10 FOR UPDATE;
-- 间隙锁会阻止其他事务在 id 大于 1 小于 10 的范围内插入数据，
-- 但允许其他事务在该范围之外的位置插入数据
COMMIT;

-- 会话 2
BEGIN;
-- 因为会话 1 对 id 大于 1 小于 10 的范围进行了间隙锁定，所以会话 2 不能在该范围内插入数据，
-- 如果执行下面的语句会一直等待会话 1 的事务提交或回滚
INSERT INTO orders (id, amount) VALUES (5, 500);


14、意向锁
是一种表级锁，，用于协调事务间的加锁操作，以避免冲突和死锁的发生。

例如，事务 A 加锁了 Users 表中的一行数据（行锁），而事务 B 要对整个 Users 表进行加锁（表锁），那么这个时候，如果没有意向锁，那事务 B 就会加锁成功了。而事务 B 如果加锁成功的话，那么它是可以对表中的任意数据行进行操作的，包括事务 A 加锁的那行数据，所以，这个时候就发生了锁冲突。




